(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Code::Initialization:: *)
(*
RigidBodySystem.nb: High-level functions used to define a rigid body.
Copyright (C) 2014 Nelson Rosa Jr.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version. This program is distributed in the 
hope that it will be useful, but WITHOUT ANY WARRANTY; without even the 
implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details. You should have 
received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.
*)


(* ::Input::Initialization:: *)
BeginPackage["RigidBodyDynamics`", "GlobalVariables`"]
Begin["`Private`"]

ni;  (* list of dof of each joint; nq = sum(ni) *)
nb; (* # of rigid bodies *)

(* rigid-body connectivity *)
parent; (* parent array *)
map; (* map from original to extended body *)
nca; (* nearest common ancestor map *)


(* ::Input::Initialization:: *)
GetTree[]:=Module[{p,t,tind},
(* get parent-child relationships *)
p = KeySelect[rb, StringQ[#] && AssociationQ@rb[#]&];
If[Length@p == 0, 
KeyDropFrom[rb, {ParentList, TreeForm, Links}];
Return[<||>]
];

p = KeyValueMap[#2["p"]->#1&,p];
p = Merge[p,Identity];

(* get tree structure w/ names *)
t = Flatten@Lookup[p,#,{}]&;
t = NestList[t,p[Root],Length@p-1];
t = Flatten@t;

(* get tree structure w/ #s *)tind = AssociationThread[Join[{Root},t]->Range[0,Length@t]];
p = tind[rb[[#,"p"]]]& /@ t;
p = AssociationThread[t->p];
t = KeyDrop[tind,Root];

AssociateTo[rb,{ParentList->p,TreeForm->t}][TreeForm]
];

GetExpandedTree[] := Module[{f, p, j},
j = RBDGetLinkInfo["joint", True];
If[Length@j == 0, Return@j];
j = If[StringQ[joint[[#1,1]]], joint[[#1]], {#1}]& /@ j;
p = Values@rb[ParentList];

nb = Length@j;
ni = Length /@ j;
nq = Total[ni];
nx = 2nq;
nc = Lookup[rb, "nc", 0];

(* allocate mem *)
parent = Range[nq] - 1;
map = ConstantArray[0, nb];

zq = Table[0, nq]; (* RNEA *)
zspat = Table[0, nq, nm]; (* RNEA *)
ZM = Table[0, nq, nq]; (* CRB *)

(* create mapping from original to extended tree *)
map[[1]] = ni[[1]];
Do[map[[i]] = map[[i-1]]+ni[[i]], {i, 2, nb}];

(* create extended tree and body arrays *)
parent[[1]] = 0;
Do[parent[[map[[i-1]]+1]] = If[p[[i]] != 0, map[[p[[i]]]], 0], {i, 2, nb}];

(* update nca *)
MakeNearestCommonAncestor[parent, nq];

(* get tree structure w/ joints *)
j = Flatten@Table[i <> "-" <> k, {i, Keys@j}, {k, j[i]}];
j = AssociationThread[j -> Range@nq];
AssociateTo[rb,Links-><| ParentList->parent,TreeForm->j |>][Links]
];


(* ::Input::Initialization:: *)
MakeNearestCommonAncestor[parent_, n_] := Module[{p},
(* nearest common ancestor (nca) *)
nca = ConstantArray[0, {n, n}];
Do[
nca[[i, i]] = i;
(* your parent's ncas are your ncas *)
p = parent[[i]];
If[p != 0, 
(* parent's ancestors + siblings *)
nca[[i, 1;;p]] = nca[[p, 1;;p]];

(* parent's siblings + kids *)
nca[[i, p+1;;i-1]] = nca[[p+1;;i-1, p]];
];
, {i, n}
];

nca = nca + LowerTriangularize[nca, -1]\[Transpose];
];

SetAttributes[GetPath, Listable];
GetPath[i_, j_:0] :=Module[{a, i2a, j2a},
(* returns the path from i to j *)
(* this can also be used to return the children on a path if a \[Element] {i, j}. *)
a = If[i == 0 || j == 0, 0, nca[[i, j]]];
i2a = NestWhileList[parent[[#]]&, i, #!= a&];

j2a = NestWhileList[parent[[#]]&, j, #!= a&];

Join[i2a, Rest@Reverse@j2a]
];


(* ::Input::Initialization:: *)
RBDTree[expanded_:True, opts:OptionsPattern[TreePlot]] := Module[{n, p},
If[expanded, 
(* extended tree *)
n = GetExpandedTree[];
p = n[ParentList];
n = Keys@n[TreeForm];,
(* original tree *)
p = rb[ParentList];
n = RBDGetLinkInfo["joint"];
n = KeyValueMap[#1 <> "-" <> #2&,n];
];

n = Table[{p[[i]]-> i, n[[i]]}, {i, Length@n}];
TreePlot[n, Automatic, 0, opts, VertexLabeling->True]
];


(* ::Input::Initialization:: *)
SetAttributes[{RBDGetIndex, RBDGetPositionIndex, RBDGetValue}, Listable];

RBDGetIndex::x = 
"Cannot use a string as an index for \[DoubleStruckX]; indices 1...`1` are valid.";
RBDGetIndex::dof = 
"Invalid index `1` for body `2`; the body only has `3` degrees of freedom.";
RBDGetIndex::n = 
"`2` is not a valid index for `1`; indices 1...`3` are valid.";
RBDGetIndex::var = 
"`1` is not a valid parameter; valid parameters are \[DoubleStruckQ], \[DoubleStruckV], \[DoubleStruckX], and \[DoubleStruckC].";
RBDGetIndex::s = 
"`1` is not a valid link name; links `2` are valid.";
RBDGetIndex::jnt = 
"`1` is not a valid joint name; links `2` are valid.";
RBDGetIndex::arg = "`1` is an invalid argument.";

(* replaces q or v, not x. *)
RBDGetIndex[f_[Root|0, _]] := 0;
RBDGetIndex[f_[i_String, j_]] := Module[{b},
b = Lookup[rb, TreeForm, GetTree[]];
b = Lookup[b, i, StringRiffle[Keys@b, ", "]];
If[IntegerQ[b], RBDGetIndex[f[b, j]], Message[RBDGetIndex::s, i, b]]
];

RBDGetIndex[f_[i_String, j_String]] := RBDGetIndex@RBDGetDOF[f[i, j]];

(* x is undetermined w/ just name *)
RBDGetIndex[\[DoubleStruckX][i_String]] := 
Message[RBDGetIndex::x, i, nx];

RBDGetIndex[f_[i_Integer, j___Integer]] := Module[{n},
n = If[f === \[DoubleStruckV], nq, 0];
Which[
f === \[DoubleStruckQ] || f === \[DoubleStruckV],
Which[!(0 < i <= nb), 
Message[RBDGetIndex::n, "\[DoubleStruckQ] or \[DoubleStruckV]", i, nb], 
!(0<Abs[j] <= ni[[i]]),
Message[RBDGetIndex::dof, j, i, ni[[i]]],
j > 0, map[[i]]+j - ni[[i]] + n,
True (*j < 0*), map[[i]]+j + 1 + n
],

f === \[DoubleStruckC],
Which[
0<i <= nc, i, 
-nc <= i < 0, nc + i + 1,
True, Message[RBDGetIndex::n, "\[DoubleStruckC]", i, nc]
],

f === \[DoubleStruckX],
Which[
0<i <= nx, i, 
-nx <= i < 0, nx + i + 1,
True, Message[RBDGetIndex::n, "\[DoubleStruckX]", i, nx]
],

True,Message[RBDGetIndex::var, f]
]
];

RBDGetPositionIndex[b_] := Which[
IntegerQ[b] && 1 <= b <= nq, b, 
StringQ[b] || b === Root, RBDGetIndex[\[DoubleStruckQ][b, -1]], 
Head[b] === \[DoubleStruckQ], RBDGetIndex[b],
IntegerQ[b], Message[RBDGetIndex::n, "\[DoubleStruckQ]", b, nq],
True, Message[RBDGetIndex::arg, b]
];

Options[RBDGetValue] = {"e" -> True, "n" -> False};

RBDGetValue[i_Integer, j_Integer, opts:OptionsPattern[]] := RBDGetValue[Range[i, j], opts];

RBDGetValue[i_, OptionsPattern[]] := Module[{n, k, f, exp, nam},
(* body index or expanded index? *)
exp = OptionValue["e"];
(* numeric or string name? *)
nam = OptionValue["n"];
Which[
(* state index *)
exp && 1 <= i <= 3nq,
{f, n} = Which[i > nx, {\[DoubleStruckA], i-nx}, i > nq, {\[DoubleStruckV], i-nq}, True, {\[DoubleStruckQ], i}];
k = Select[Range@Length@map, n <= map[[#]]&, 1][[1]];
n = If[k == 1, n, n - map[[k-1]]];
k = Keys[Lookup[rb, TreeForm, GetTree[]]][[k]];
If[nam, RBDGetDOF[f[k, n]], f[k, n]],
(* body index *)
1 <= i <= nb,
{f, k} = If[i > nb, {\[DoubleStruckV], i - nb}, {\[DoubleStruckQ], i}];
n = If[k == 1, map[[k]], map[[k]]-map[[k-1]]];
k = Keys[Lookup[rb, TreeForm, GetTree[]]][[k]];
If[nam, RBDGetDOF[f[k, n]], f[k, n]],
(* error messages *)
exp, Message[RBDGetIndex::n, "\[DoubleStruckX]", i, nx],
True, Message[RBDGetIndex::n, "\[DoubleStruckQ] or \[DoubleStruckV]", i, nb]
]
];


(* ::Input::Initialization:: *)
ConvertToXL[expr_] := RBDExpandExpression[expr] /. {
h_ /; MemberQ[{\[DoubleStruckQ], \[DoubleStruckV], \[DoubleStruckX]}, Head[h]] :> \[DoubleStruckX][RBDGetIndex[h]], 
h_ /; Head[h] === \[DoubleStruckC] :> \[DoubleStruckC][RBDGetIndex[h]]
};

Options[ConvertToXLFunction] = {"dot" -> False, "c" -> Automatic, "cdot" -> Automatic};

ConvertToXLFunction[expr_, OptionsPattern[]] := Module[{dot, e, edot, f, c, cdot},
dot = OptionValue["dot"];
f = With[{a = ConvertToXL@#}, a&]&;

e = f[expr];
edot = If[dot, 
c = OptionValue["c"];
If[c === Automatic, c = RBDGetValue[1, nq, "n" -> False]];
cdot = OptionValue["cdot"];
If[cdot === Automatic, cdot = RBDGetValue[nq+1, nx, "n" -> False]];
f[Con[expr, c, cdot]], 
(* else *)
{}
];

Block[{Part}, 
f = {\[DoubleStruckX][i__] :> Part[Slot[1], i], \[DoubleStruckC][i__] :> Part[Slot[2], i]};
If[dot, {e, edot}, e]  /. f
]
];


(* ::Input::Initialization:: *)
End[]
EndPackage[]
