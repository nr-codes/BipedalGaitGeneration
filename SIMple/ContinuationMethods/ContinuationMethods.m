(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["ContinuationMethods`"]

tmon::usage = "";
defmon::usage = "";
armmon::usage = "";

Man0::usage = "";
Man::usage = "";

Begin["`Private`"]

(* manifold *)
f = None;
ftol = 10^-5;
man = <||>;

(* tree depth *)
t = tmax = 0;

(* time *)
t0 = 0;
ttot = 0;
nps = 0;

(* tangent space, ns[c, r, dr, h] *)
ns = {ConstantArray[0, Length@#1]}&;
nstol = Automatic;

(* neighborhood *)
neighbors = {}&;

(* interface functions *)
Q = <||>;


(* ::Input::Initialization:: *)
initNbrhood[h_, meth_] := If[meth === cmarmijo,
(* don't modify h as it contains gradient direction *)
With[{nb = ConstantArray[1, Length@h]}, {#+nb}&],
(* else, create a local grid of points *)
With[{nb = setNbrhood[Length@h]}, Table[#+n, {n, nb}]&]
]

setNbrhood[n_] := Module[{z0, p0, N},
Quiet@Check[
Tuples[{-1, 0, 1}, {n}],
z0 = ConstantArray[0, n];
p0 = Range[n];
Join@@Table[CFKz[z0, RotateRight[p0, i-1], j], {i, n}, {j, {1, n+1}}]
]
];


(* ::Input::Initialization:: *)
rm[Df_] := Module[{U, T, k},
U = Transpose@NullSpace[Df, Tolerance -> nstol];
k = Dimensions[U];
(* as laid out in the paper: T is permuted IdentityMatrix *)
 Transpose@MaximalBy[IdentityMatrix@k[[1]], Norm[U\[Transpose].#]&, k[[2]]]
];

mf[Df_, RM_] := Module[{T, U, Q},
T = If[RM === {}, T0 = rm[Df], RM];

U = NullSpace[Df, Tolerance -> nstol]\[Transpose];
Q = SingularValueDecomposition[U\[Transpose].T];
Q = Q[[1]].Q[[3]]\[Transpose];
U.Q
];


(* ::Input::Initialization:: *)
nscurve[Df_, NS0_] := Module[{NS},
NS = NullSpace[Df, Tolerance -> nstol][[1;;1]];
If[NS0 =!= {} && NS[[1]].NS0[[1]] < 0, -NS, NS]
];


(* ::Input::Initialization:: *)
setNS[f_:Automatic, n_:1] := Module[{},
T0 = {};
Which[
(* 1-D continuation *)
f === Automatic && n == 1, nscurve[#3, #4]&,
(* multi-D continuation *)
f === Automatic, mf[#3, T0]\[Transpose]&,
(* custom *)
True, f
]
];


(* ::Input::Initialization:: *)
tmon[t_, h_:""] := Module[{m, n, N},
m = Length@man;

ttot = AbsoluteTime[] - t0;
nps = If[PossibleZeroQ[ttot], 0, m/ttot];

m = ToString[m];
n = ToString@NumberForm[ttot, {4, 3}];
N = ToString@NumberForm[nps, {4,3}];

h <> " depth: " <> ToString[t] <> " nodes: " <> m <>  " nodes per second: " <> N <> " elapsed time: " <> n
];

tmon[t0_, k_, man_, OptionsPattern[]] := If[t0 == 0, PrintTemporary@Dynamic[tmon[t, "tmon ---"]]];

defmon[t_, k_, man_, OptionsPattern[]] := Print[tmon[t, "defmon ---"], " node: ", k];

armmon[t_, k_, man_, OptionsPattern[cmarmijo]] := Module[{fDf, f, min, r},
f = man[k];
f = If[f === $Failed,  \[Infinity], f[[4]]];

r = If[OptionValue[Root], "root", "min"];

min = f < OptionValue["ftol"];
Print["armmon (", r,  ") --- depth: ", t, " node: ", k, " f: ", f, If[min, " <--- minimizer or root!", ""]];

If[min && OptionValue[Abort], Abort[]];
];


(* ::Input::Initialization:: *)
Man0::root = "c0 must yield a known root of f.  Norm[f(c0)] is too large `1` (> 10^-5).";

Man0::bif = "Tangent space is `` dimensional; expected a `` dimensional tangent space.  A basis for the tangent space is: ``.";

Man0[C0_, z0_, c0_, NS_, h_, opts:OptionsPattern[]] := Module[{r, dr, C, ftol},
ftol = OptionValue[cm, opts, "newton"];
ftol = OptionValue[newton, ftol, "ftol"];

(* set up initial point on curve *)
If[NS === {}, 
{r, dr} = f[c0];
C = {c0, ns[c0, r, dr, {}], h};, 
(* else *)
C = {c0, NS, h};
{r, dr} = f[C[[1]]];
];

C = Join[C, C0[C]];

If[Norm[r] >  ftol, 
Message[Man0::root,Norm[r]];
Throw[$Failed];
];

man[z0] = C;
If[Length@C[[2]] != Length@C[[3]],
Message[Man0::bif, Length@C[[2]], Length@C[[3]], MatrixForm@C[[2]]];
Throw[$Failed];
];

mon[t, z0, man, opts];
KeyTake[man, {z0}]
];


(* ::Input::Initialization:: *)
Man0[z0_, opts:OptionsPattern[]] := Module[{z},
If[man[z0] =!= $Failed, 
(* generate neighborhood *)
z = neighbors[z0];
z = Select[z, KeyFreeQ[man, #]&];

Do[
man[k] = Catch[cm[k, z0, man[z0], opts]];
mon[t, k, man, opts];, 
{k, z}
];

KeyTake[man, z],
(* else *)
<||>
]
];


(* ::Input::Initialization:: *)
Options[Man] := {"s" -> (#&), "a" -> AssociateTo, "r" -> KeyDropFrom, "n" -> Automatic, Method -> cmc, Monitor -> (Null&), "ns" -> Automatic, "nstol" -> nstol, NullSpace -> {}, "cm" -> {}, "C0" -> ({}&)};

Man[root_, c0_, h_, N_, opts:OptionsPattern[]] := Module[{sel, add, rmv, z0, z, Z0, o},
(* set up manifold and continuation method *)
man = <||>;
f = root;
cm = OptionValue[Method];
o = OptionValue["cm"];

(* set up tangent space *)
ns = setNS[OptionValue["ns"], Length@h];
nstol = OptionValue["nstol"];

(* setup neighborhood *)
neighbors = OptionValue["n"];
If[neighbors === Automatic, neighbors = initNbrhood[h, cm]];

(* monitor, called after a point is found *)
mon = OptionValue[Monitor];

(* depth of tree *)
t = 0;
tmax = N;

(* time *)
ttot = 0;
nps = 0;
t0 = AbsoluteTime[];

(* Q functions *)
Q = <||>;
sel = OptionValue["s"];
add = OptionValue["a"];
rmv = OptionValue["r"];

CheckAbort[
(* add first point *)
z0 = ConstantArray[0, Length@h];
Z0 = Man0[OptionValue["C0"], z0, c0, OptionValue[NullSpace], h, o];
add[Q, Z0];

While[t < tmax && Length@Q > 0,
t++;
z0 = Keys@sel[Q];
z = Man0[#, o]& /@ z0;
add[Q, z];
rmv[Q, z0];
];

Print@tmon[t];
man,

Print@tmon[t];
man
]
];


(* ::Input::Initialization:: *)
End[]
EndPackage[]
