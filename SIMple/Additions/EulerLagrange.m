(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["EulerLagrange`"]
If[!ValueQ[ELSystem], ELSystem::usage = ""];
If[!ValueQ[ELTestModel], ELSystem::usage = ""];
If[!ValueQ[ELp], ELp::usage = ""];
If[!ValueQ[ELpdot], ELpdot::usage = ""];
If[!ValueQ[ELKE], ELKE::usage = ""];
If[!ValueQ[ELPE], ELPE::usage = ""];
If[!ValueQ[ELM], ELM::usage = ""];
If[!ValueQ[ELc], ELc::usage = ""];
If[!ValueQ[ELF], ELF::usage = ""];
If[!ValueQ[ELdF], ELdF::usage = ""];
If[!ValueQ[ELP], ELP::usage = ""];
If[!ValueQ[ELdP], ELdP::usage = ""];
If[!ValueQ[ELJ], ELJ::usage = ""];
If[!ValueQ[ELJdot], ELJdot::usage = ""];
If[!ValueQ[ELdJ], ELJ::usage = ""];
If[!ValueQ[ELdJdot], ELJdot::usage = ""];
If[!ValueQ[ELsteps], ELsteps::usage = ""];
If[!ValueQ[ELPostProcess], ELPostProcess::usage = ""];

Begin["`Private`"]
vp;
pf;
\[DoubleStruckCapitalI];

ELsteps = {"p"-> 1, "pdot"->2, "\[DoubleStruckCapitalI]"-> 3, "KE"-> 4, "PE"-> 5, "M"-> 6, "vp"-> 7, "pf"-> 8, "Xdot"-> 9, "dXdot"-> 10, "J"-> 11, "dJ"-> 12, "Jdot"-> 13, "dJdot"-> 14, "P"-> 15, "dP"-> 16};
postprocess = ConstantArray[Identity, Length[ELsteps]];

tests = {TestMc, TestQnt, TestP, TestF};
run = {True, True, False, False};

tests::err = "Number of tests does not equal the number of default run variables for calling TestModel, expect runtime errors.";
If[Length[run] != Length[tests], Message[tests::err]];


(* ::Input::Initialization:: *)
InertiaTensor[m_] := Module[{I},
(* create 3x3 inertia tensor *)
I = Which[VectorQ[#], DiagonalMatrix[#],
MatrixQ[#],#,
True, DiagonalMatrix[{0, 0,#}]
]&;

ArrayFlatten[{{I[#[[2]]], 0}, {0, #[[1]] IdentityMatrix[3]}}]& /@ m
];

\[CapitalGamma][M_, var_, ind_] := Module[{i, j, k}, {i, j, k} = ind; 1/2(D[M[[i,j]],var[[k]]] + D[M[[i,k]],var[[j]]] - D[M[[k,j]],var[[i]]])];

VP[M_, X_, nq_] := Array[Sum[\[CapitalGamma][M, X, {#1,#2,k}]X[[k+nq]], {k, nq}]&, {nq,nq}];

SetAttributes[process, HoldFirst];
process[expr_, i_] := Module[{pp = postprocess[[i]]}, pp[expr]];


(* ::Input::Initialization:: *)
ELSystem::ndof = "There are `1` mass parameters, but `2` spatial vectors.  The two must be equal."

ELSystem[nq_, mass_,pcom_, gravity_, cons_:({}&), OptionsPattern[]] := Module[{A, ret1, ret2, X, U, xx, uu, g, m},
If[Length[mass] != Length[pcom],Message[ELSystem::ndof, Length[mass], Length[pcom]]; Return[]];

A = \!\(\*
TagBox[
RowBox[{"(", "", GridBox[{
{"0", "0", "0"},
{"0", "0", "0"},
{"1", "0", "0"},
{"0", "1", "0"},
{"0", "0", "1"},
{"0", "0", "0"}
},
GridBoxAlignment->{"Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.7]}, Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}}], "", ")"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\); (* convert from 3D to 6D spatial vectors *)

Off[Part::partd];
Off[Part::take];

X = Array[xx[[#]]&, 2nq];
U = Array[uu[[#]]&, nq];
g = If[VectorQ[gravity], PadLeft[gravity, 6],{0,0,0,0,gravity,0}];
m = If[VectorQ[#], #, #[X]]& /@ mass;

(* step 1, ret1 = Null, ret2 = Null *)
ret1 = process[If[Length[#[X]] == 3, A.#[X], #[X]]& /@ pcom, 1];
ELp[x_] := Evaluate[ret1 /. xx-> x];
(* step 2, ret1 = p, ret2 = Null *)
ret2 = process[D[#, {X[[;;nq]]}].X[[-nq;;]]& /@ ret1, 2];
ELpdot[x_] := Evaluate[ret2 /. xx-> x];
(* step 3, ret1 = p, ret2 = pdot *)
\[DoubleStruckCapitalI] = process[createInertiaTensor[m],3];
(* step 4, ret1 = p, ret2 = pdot *)
ret2 = process[1/2Total[MapThread[#1.#2.#1&, {ret2, \[DoubleStruckCapitalI]}]],4];
ELKE[x_] :=  Evaluate[ret2 /. xx-> x];
(* step 5, ret1 = p, ret2 = KE *)
ret1 = process[Total[m[[All, 1]]*(ret1.g)], 5];
ELPE[x_] := Evaluate[ret1 /. xx-> x];
(* step 6, ret1 = PE, ret2 = KE *)
ret2 = process[D[ret2, {X[[-nq;;]], 2}], 6];
ELM[x_]:= Evaluate[ret2 /. xx-> x];
(* step 7, ret1 = PE, ret2 = M *)
ret2 = process[VP[ret2, X, nq].X[[-nq;;]], 7];
vp[x_] :=  Evaluate[ret2 /. xx-> x];
(* step 8, ret1 = PE, ret2 = vp *)
ret1 = process[D[ret1, {X[[;;nq]]}], 8];
pf[x_] := Evaluate[ret1 /. xx-> x];
ELc[x_] := Evaluate[(ret1+ret2) /. xx-> x];
(* step 9, ret1 = pf, ret2 = vp *)
ret1 = ret1+ret2;
ret2 = Inverse[ELM[X]];
ret1 = process[ret2.(U- ret1), 9];
ELF[x_, u_]:= Evaluate[ret1 /. {xx-> x, uu-> u}];
(* step 10, ret1 = F, ret2 = Inverse[M] *)
ret1 = process[D[ret1, {Join[X,U]}], 10];
ELdF[x_, u_]:= Evaluate[ret1 /. {xx-> x, uu-> u}];
(* step 11, ret1 = dF, ret2 = Inverse[M] *)
A = cons[X];
ret1 = process[A, 11];
ELJ[x_] := Evaluate[ret1 /. xx-> x];
(* step 12, ret1 = J, ret2 = Inverse[M] *)
ret1 = process[D[ELJ[X], {Join[X, U]}], 12];
ELdJ[x_] := Evaluate[ret1 /. xx-> x];
(* step 13, ret1 = dJ, ret2 = Inverse[M] *)
ret1 = process[If[A == {}, A, X[[-nq;;]].ret1[[All,All,;;nq]]\[Transpose]], 13];
ELJdot[x_] := Evaluate[ret1 /. xx-> x];
(* step 14, ret1 = Jdot, ret2 = Inverse[M] *)
ret1 = process[D[ELJdot[X], {Join[X,U]}], 14];
ELdJdot[x_] := Evaluate[ret1 /. xx-> x];
(* step 15, ret1 = dJdot, ret2 = Inverse[M] *)
ret1 = If[A == {}, A, ELJdot[X].X[[-nq;;]] + ELJ[X].ELF[X, U]];
(* NLinks uses PseudoInverse, but it can take forever to compute *)
ret2 = process[If[A == {}, A, ELF[X, U] - ret2.A\[Transpose].Inverse[A.ret2.A\[Transpose]].ret1], 15];
ELP[x_, u_] := Evaluate[ret2 /. {xx -> x, uu-> u}];
(* step 16, ret1 = Jdot.qdot + J.F, ret2 = P *)
ret2 = process[D[ret2, {Join[X,U]}], 16];
ELdP[x_, u_] := Evaluate[ret2 /. {xx -> x, uu -> u}];

On[Part::partd];
On[Part::take];
];

ELPostProcess[pp_] := Module[{ppnew},
ppnew = pp /. ELsteps;
Scan[(postprocess[[#[[1]]]] = #[[2]])&, ppnew]
];


(* ::Input::Initialization:: *)
test[{t_, a_, b_}] := Module[{n, f},
n = (a - b) // Simplify;
n = Norm[n];
If[NumericQ[n] && Chop[N@n, 10^-6] == 0, 
Print["Success! " <> t <> " are equal."], 
Print["Nooooo... " <> t <> " are not equal."]
];

{Simplify@a, Simplify@b, n}
]

ELTestModel::tests = "The number of tests available `1` does not equal the number you want to run `2`.";

ELTestModel::der = "Tests that require derivatives will not work properly unless nd equals 3 nq.  Calling SetModel with the optional derivative argument set to All resolves the issue.";

ELTestModel[x_, u_, run_:run] := Module[{f, r},
If[run === All,
r = ConstantArray[True, Length[tests]],
r = run;
];

If[NLink`Private`nd != 3NLink`Private`nq, 
Message[ELTestModel::der, NLink`Private`nd, 3 NLink`Private`nq]; 
];

If[Length[r] != Length[tests],
Message[ELTestModel::tests, Length[tests], Length[r]],
f = If[#1, 
Print["Running ", #2];#2[x, u], 
Print["Skipping ", #2]
]&;
MapThread[f, {r, tests}]
]
];

TestMc[x_, u_:0] := Module[{NM, M, NC, c},
NLink`Private`EvaluateFunctions[x];
NLink`Private`Fcrb[x, NLink`Private`znq];

NM = NLink`Private`Mx[NLink`Private`M, IdentityMatrix[NLink`Private`nq]];
M = ELM[x];
NC = NLink`Private`uJ;
c = ELc[x];

test /@ {{"M's", M, NM}, {"c's", c, NC}}
]

TestQnt[x_, u_:0] := Module[{Nqnt, pcom, PE, KE},
Nqnt = NLink`Private`MechanicalQuantities[x];
pcom = Total[\[DoubleStruckCapitalI][[All, 6,6]]*ELp[x][[All, 4;;6]]]/Total[\[DoubleStruckCapitalI][[All, 6,6]]];
KE = ELKE[x];
PE = ELPE[x];

test /@ {{"KE's", KE, Nqnt[[1]]}, {"PE's", PE, Nqnt[[2]]}, {"com's", pcom, Nqnt[[-2]]}}
]

TestP[x_, u_] := Module[{qd, dx, du, NF, F, NJ, J, NJdot, Jdot, NP, P, NdF, dF, NdJ, dJ, NdJdot, dJdot, NdP, dP},
qd = x[[-NLink`Private`nq;;]];
dx = IdentityMatrix[{NLink`Private`nx, NLink`Private`nd}];
du = PadLeft[IdentityMatrix[NLink`Private`nq], {NLink`Private`nq, NLink`Private`nd}];

NLink`Private`EvaluateFunctions[x];
NLink`Private`EvaluateDerivatives[x, dx];

NF = NLink`Private`Fcrb[x, u];
NdF = NLink`Private`dFcrb[x, u, dx, du];
NP = NLink`Private`P[x, NF];
NdP = NLink`Private`dP[x, dx, NF, NdF];
NJ = NLink`Private`J;
NJdot = NLink`Private`Jdot;
NdJ = NLink`Private`dXb[NLink`Private`dJ, qd];
NdJdot = NLink`Private`dXb[NLink`Private`dJdot, qd];

F = ELF[x, u];
dF = ELdF[x, u];
P = ELP[x, u];
J = ELJ[x];
Jdot = ELJdot[x];
dP = ELdP[x, u];
dJ = NLink`Private`dXb[ELdJ[x], qd];
dJdot = NLink`Private`dXb[ELdJdot[x], qd];

test /@ {{"F's", F, NF}, {"dF's", dF, NdF}, {"J's", J, NJ}, {"dJ's", dJ, NdJ}, {"Jdot's", Jdot, NJdot}, {"dJdot's", dJdot, NdJdot}, {"P's", P, NP}, {"dP's", dP, NdP}}
];

TestF[x_, u_] := Module[{dx, du, NFaba, NFcrb, F, NdFaba, NdFcrb, dF},
dx = IdentityMatrix[{NLink`Private`nx, NLink`Private`nd}];
du = PadLeft[IdentityMatrix[NLink`Private`nq], {NLink`Private`nq, NLink`Private`nd}];

NLink`Private`EvaluateFunctions[x];
NLink`Private`EvaluateDerivatives[x, dx];

(* IC is modified, so use a block to revert back to original values *)
Block[{NLink`Private`IC = NLink`Private`IC, NLink`Private`dIC = NLink`Private`dIC},
NFaba = NLink`Private`Faba[x, u];
];

NFcrb = NLink`Private`Fcrb[x, u];
NdFcrb = NLink`Private`dFcrb[x, u, dx, du];

F = ELF[x, u];
dF = ELdF[x, u];

test /@ {{"F's using ABA", F, NFaba}, {"F's using CRB", F, NFcrb}, {"dF's using CRB", dF, NdFcrb}}
];


(* ::Input::Initialization:: *)
End[]
EndPackage[]
