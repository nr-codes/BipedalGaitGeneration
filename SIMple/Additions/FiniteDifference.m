(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Code::Initialization:: *)
(*
FiniteDifference.nb: Gives list of functions that are exported by the NLinks package.
Copyright (C) 2014 Nelson Rosa Jr.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version. This program is distributed in the 
hope that it will be useful, but WITHOUT ANY WARRANTY; without even the 
implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details. You should have 
received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.
*)


(* ::Input::Initialization:: *)
BeginPackage["Derivatives`"]

FiniteDifferenceJacobian::usage = "";
FiniteDifferenceHessian::usage = "";

Begin["`Private`"]


(* ::Input::Initialization:: *)
(* based on https://www.geometrictools.com/Documentation/FiniteDifferences.pdf *)
(* also useful: https://v8doc.sas.com/sashtml/ormp/chap5/sect28.htm *)

SetAttributes[FiniteDifferenceCoefficients, Listable];
FiniteDifferenceCoefficients[d_:1, p_:2, t_:"c"] := Module[{A, b, C, imin, imax},
(* compute d-th derivative with p precision using t differencing *)
(* in one variable.  Then returns a pair (C, i) s.t. df/dx = C*f[x+i*dx] *)
{imin, imax} = Which[
(* forward difference *)
t === "f", {0, d+p-1},
(* backward difference *)
t === "b", {-(d+p-1), 0},
(* central difference *)
t === "c", {-Floor[(d+p-1)/2], Floor[(d+p-1)/2]},
True,
Throw@$Failed
];

A = Table[If[n == 0, 1, i^n], {n, 0, d + p - 1}, {i, imin, imax}];
b = ConstantArray[0, d+p];
b[[d+1]] = 1;
C = LinearSolve[A, b];

(* assumes keys are ordered from min to max *)
A = AssociationThread[Range[imin, imax] -> C];
Join[A, AssociationThread[{"d", "p", "t"} -> {d, p, t}]]
];


FiniteDifferenceFormula[k_Integer, FDC_] := FiniteDifferenceFormula[{k}, {FDC}];
FiniteDifferenceFormula[k_, FDC_] := Module[{n, a, A, I, e, d, C},
Block[{f, c, h, i, x},
n = Length@k;
If[Length[FDC] != n, Throw[$Failed]];
(* assumes keys are ordered from min to max *)
I = Keys /@ FDC[[All, ;;-4]]; (* ignore keys d, p, t *)
(* generate indices *)
I = Sequence@@Array[{i[#], I[[#, 1]], I[[#, -1]]}&, n];
(* generate deltas, h is same dimension as c *)
a = Plus@@Array[h[k[[#]]]x[k[[#]]] i[#]&, n];
(* generate step sizes *)
d = FDC[[All, "d"]];
d = Times@@Array[h[k[[#]]]^d[[#]]/d[[#]]!&, n];
(* generate coefficients *)
A = Times@@Array[C[#, i[#]]&, n];
(* put together equation *)
e = A f[c+a];
Simplify[Sum[e, Evaluate@I]/d /. C[i_, j_] :> FDC[[i,Key@j]]]
]
];

FiniteDifferenceFunction[k_, d_:1, p_:2, t_:"c"] := Module[{D, FDC},
FDC = FiniteDifferenceCoefficients[d, p, t];
Block[{f, c, h, i, x},
D = FiniteDifferenceFormula[k, FDC];
(* assumes that arguments in x & h are valid indices *)
If[IntegerQ[k],
(* no need to index into variables only 1 h & x exist *)
Evaluate@D& /. {f -> #1, c -> #2, h[i_] :> #3, x[i_] :> #4},
(* index into variables *)
Evaluate@D& /. {f -> #1, c -> #2, h[i_] :> #3[[i]], x[i_] :> #4[[i]]}
]
]
];

FiniteDifferenceJacobian[f_, c_, h_, p_:2, t_:"c"] := Module[{D, I},
If[Length@c != Length@h && Length@h > 0, Return[$Failed]];
D = FiniteDifferenceFunction[1, 1, p, t];
I = IdentityMatrix@Max[1, Length@c];
Which[
VectorQ@c && VectorQ@h,
MapThread[D[f, c, #1, #2]&, {h, I}],
VectorQ@c,
Map[D[f, c, h, #]&, I],
True,
D[f, c, h, I[[1]]]
]
];

FiniteDifferenceHessian[f_, c_, h_, p_:2, t_:"c"] := Module[{n, DXX, DXY, I, d1, d2},
n = Length@c;
If[n != Length@h && Length@h > 0, Return[$Failed]];
DXX = FiniteDifferenceFunction[1, 2, p, t];
DXY = FiniteDifferenceFunction[{1, 2}, {1, 1}, p, t];
d1 = Range@n;
d2 = Subsets[d1, {2}];
I = IdentityMatrix@Max[1, n];
Which[
VectorQ@c && VectorQ@h,
DXX = DXX[f, c, h[[#]], I[[#]]]& /@ d1;
DXY = DXY[f, c, h[[#]], I[[#]]]& /@ d2;,
VectorQ@c,
DXX = DXX[f, c, h, I[[#]]]& /@ d1;
DXY = DXY[f, c, {h, h}, I[[#]]]& /@ d2;,
True,
DXX = DXX[f, c, h, I[[1]]];
DXY = 0;
];

{DXX, DXY}
];


(* ::Input::Initialization:: *)
End[]
EndPackage[]
