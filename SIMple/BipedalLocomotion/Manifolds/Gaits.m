(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["BipedalLocomotion`", {"GlobalVariables`", "RigidBodyDynamics`", "HybridDynamics`", "ContinuationMethods`", "BipedalLocomotion`Model`"}]

Begin["`Private`"]


(* ::Input::Initialization:: *)
Options[BLTangentSpace] = {"P" -> BLP, "nstol" -> OptionValue[Man, {}, "nstol"], BLFindBifurcation -> {}};

BLTangentSpace[c_, OptionsPattern[]] := Module[{m0, c0, R, nstol, FBopts},
R = OptionValue["P"];
nstol = OptionValue["nstol"];
FBopts = OptionValue[BLFindBifurcation];
m0 = BLbiped["m[0]"];
c0 = c;
If[NumericQ[c0], c0 = BLbiped["\[DoubleStruckC]", m0, "eq"]@BLFindBifurcation[R, c0, Automatic, FBopts][[1]];];
MatrixForm@NullSpace[R[c0][[2]], Tolerance->nstol]
]


(* ::Input::Initialization:: *)
(* assumes we are starting at an equilibrium point *)
Options[BLGenerateGaits] = {Man -> {}, BLFindBifurcation -> {}, "T" -> Automatic};
BLGenerateGaits[P_, t_, h_, N_, opts:OptionsPattern[]] := Module[{n, c, T},
If[NumericQ[t],
(* switching time given, use P or a different map? *)
T = OptionValue["T"];
If[T === Automatic, T = P];
(* find bifurcation *)
T = First@BLFindBifurcation[T, t, Automatic, OptionValue[BLFindBifurcation]];
c = BLbiped["\[DoubleStruckC]", BLbiped["m[0]"], "eq"][T];,
(* else *)
(* c[0] given *)
c = t;
];

n = HybridDynamics`Private`o;
If[n >= 2, Print["Higher order derivatives not yet implemented"]];
If[n == 0, Print["finite-difference of derivatives not yet implemented"]];

Man[P, c, h, N, OptionValue[Man]]
];


(* ::Input::Initialization:: *)
ghmon[t_, k_, man_, OptionsPattern[cmarmijo]] := Module[{fDf, f, min, msg},
f = man[k];
f = If[f === $Failed, \[Infinity], f[[4]]];
If[!OptionValue[Root], 
f = Sqrt[2 f];
msg = "minimizer";, 
(* else *) 
msg = "root";
];

min = f < OptionValue["ftol"];
Print["ghmon --- depth: ", t, " node: ", k, " f: ", f, If[min, " <--- " <> msg <> "!", ""]];
If[min && OptionValue[Abort], Abort[]];
];

Options[BLGlobalHomotopy] = {"P" -> BLP, BLP -> {}, "H" -> ({{}}&), Man -> {}};

BLGlobalHomotopy[cp_, opts:OptionsPattern[]] := BLGlobalHomotopy[BLbiped["m[0]"], cp, opts];

BLGlobalHomotopy[m_String, cp_, opts:OptionsPattern[]] := 
Module[{f0, g0, R0, H0, a, b, P, obj, ns},
(* root *)
f0 = OptionValue["P"];
(* homotopy *)
g0 = OptionValue["H"];

(* initial values *)
R0 = f0[m, cp, OptionValue[BLP]];
H0 = g0[m, cp, Map -> R0];

a = H0[[1]];
b = a/a.a;

(* root function *)
P = With[{h0 = a, n0 = b, f = f0, g = g0}, 
Module[{c, o, \[Lambda], R, H},
c = #1;
o = ##2;

(* apply homotopy *)
R = f[m, c, o];
H = g[m, c, Map -> R];

(* homotopy parameter *)
\[Lambda] = n0.H[[1]];

(* homotopy function *)
R = R["R"];
H[[1]] = Join[R[[1]], H[[1]] - \[Lambda] h0];
If[Length@H > 1,
H[[2]] = Join[R[[2]], H[[2]] - Outer[Times, h0, n0.H[[2]]]];
];

H
]&
];

a = OptionValue[Man];
a = OptionValue[Man, a, "cm"];

(* objective function *)
obj = With[{n0 = b, g = g0}, 
If[OptionValue[cmarmijo, a, Root],
Module[{H}, 
H = g[m, ##];
(* +'ve gradient *)
{0.5(n0.H[[1]])^2, {n0.H[[1]]}, {n0.H[[2]]}}
]&,
(* else minimize homotopy parameter *)
Module[{H}, 
H = g[m, ##];
(* +'ve gradient *)
{0.5(n0.H[[1]])^2, n0.H[[1]] n0.H[[2]], 0}
]&
]
];

(* gradient in tangent space *)
ns = With[{f = obj}, 
If[OptionValue[cmarmijo, a, Root],
Module[{n, N, d}, 
(* dc/ds *)
n = NullSpace[#3]\[Transpose];
(* df/ds = df/dc dc/ds *)
N = f[#1][[3]].n;
(* Newton step, solve for \[CapitalDelta]s *)
d = -LinearSolve[N, f[#1][[2]]];

{n.d}
]&,
(* else *)
Module[{n = NullSpace[#3]\[Transpose]}, {-n.(f[#1][[2]].n)}]&
]
];

{P, obj, ns}
];

BLGlobalHomotopy[{P_, H_}, c_, h_, N_, opts:OptionsPattern[]] := Module[{r, obj, ns, o, cm},
{r, obj, ns} = BLGlobalHomotopy[c, "P" -> P, "H" -> H, opts];

(* add to cm options *)
o = OptionValue[Man];
If[!ListQ[o], o = {o}];

cm = "cm" /. Append[o, "cm" -> {}];
cm = Join[{"f" -> obj, Abort -> True}, cm];

(* add to Man options *)
cm = {"C0" -> (obj[#[[1]]][[1;;1]]&), Monitor -> ghmon,  Method -> cmarmijo, "ns" -> ns, "cm" -> cm};

o = Join[cm, o];

Man[r, c, h, N, o]
];


(* ::Input::Initialization:: *)
End[]
EndPackage[]
