(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Code::Initialization:: *)
(*
SpatialVectors.nb: A spatial vector algebra package based 
on Featherstone's Spatial_v2 software 
(http://royfeatherstone.org/spatial/v2/index.html).
Copyright (C) 2014 Nelson Rosa Jr.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version. This program is distributed in the 
hope that it will be useful, but WITHOUT ANY WARRANTY; without even the 
implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details. You should have 
received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.
*)


(* ::Input::Initialization:: *)
BeginPackage["RigidBodyDynamics`", "GlobalVariables`"]
Begin["`Private`"]


(* ::Input::Initialization:: *)
(* rotate the frame "foward" *)
rot3[q_, a_] := RotationMatrix[-q, a];

(* take 3x3 matrices and make a 6x6 matrix *)
Mat6[M11_, M12_, M21_, M22_] := ArrayFlatten[{{M11, M12}, {M21, M22}}]


(* ::Input::Initialization:: *)
(* cross products, useful for coordinate transforms of spatial velocities and forces *)
skew[x_] :=({
 {0, -x[[3]], x[[2]]},
 {x[[3]], 0, -x[[1]]},
 {-x[[2]], x[[1]], 0}
});

deskew[S_] :=1/2{S[[3,2]]-S[[2,3]], S[[1,3]]-S[[3,1]], S[[2,1]] - S[[1,2]]};

mx[m_] := Mat6[skew@m[[1;;3]], Z3, skew@m[[4;;6]], skew@m[[1;;3]]];

mxstar[m_] := -mx[m]\[Transpose];

(* primarily used to get compilable code *)
mxv = mx[#1].#2&;
mxX = mxv;
mxstarf = mxstar[#1].#2&;
mxstarIv = mxstarf[#1, #2.#3]&;


(* ::Input::Initialization:: *)
transX[x_] :=Mat6[I3, Z3,  -skew@I3[[1]] x, I3];
transY[y_] :=Mat6[I3, Z3,  -skew@I3[[2]] y, I3];
transZ[z_] :=Mat6[I3, Z3,  -skew@I3[[3]] z, I3];
trans[r_] :=transZ[r[[3]]].transY[r[[2]]].transX[r[[1]]];

rotX[\[CurlyPhi]_] := Mat6[rot3[\[CurlyPhi], I3[[1]]], Z3, Z3, rot3[\[CurlyPhi], I3[[1]]]];
rotY[\[Theta]_] := Mat6[rot3[\[Theta], I3[[2]]], Z3, Z3, rot3[\[Theta], I3[[2]]]];
rotZ[\[Psi]_] := Mat6[rot3[\[Psi], I3[[3]]], Z3, Z3, rot3[\[Psi], I3[[3]]]];
rot[q_] := rotZ[q[[3]]].rotY[q[[2]]].rotX[q[[1]]];

(* transform from a to b coordinates *)
Xba[x_] := rot[x[[1;;3]]].trans[x[[4;;6]]];
Xstarba[x_] := Inverse@Xba[x]\[Transpose];

InvXba[xba_?VectorQ] := InvXba[Xba[xba]];
InvXba[Xba_] :=Module[{X, R, p},
X = Xba;
R = X[[1;;3,1;;3]]\[Transpose];
p = -X[[4;;6,1;;3]];
X[[1;;3,1;;3]] = R;
X[[4;;6,4;;6]] = R;
X[[4;;6,1;;3]] = R.p.R;
X
];


(* ::Input::Initialization:: *)
(* inertia coordinate transformation *)
Io[m_, x_, Ic_] := Module[{I},
(* I is about com of link *)
I = KroneckerProduct[({
 {1, 0},
 {0, 0}
}), Ic] + KroneckerProduct[({
 {0, 0},
 {0, 1}
}), m I3];
Xba[x]\[Transpose].I.Xba[x] (* formula from Springer's HoR, (3.32) *)
];

mcI[Io_] := Module[{m, c, I},
m = Io[[4,4]];
I = Io[[1;;3, 4;;6]];
If[m != 0, I /= m;];
(* based on expanding Io, rotations always cancel out of equation *)
c = Join[z3, deskew[I]];
I = Io[[1;;3, 1;;3]] - I.Io[[4;;6, 1;;3]];
Flatten[{m, c, I}]
];

Itot[\[DoubleStruckCapitalI]c__] := Module[{m, Icom, pos, I},
I = If[VectorQ[#], #, Sequence@@#]& /@ {\[DoubleStruckCapitalI]c};
(* add the spatial inertias assuming same origin O *)
Plus@@Table[
m = si[[1]];
pos = si[[2;;7]];
If[Length[si] == 10, 
Icom = DiagonalMatrix[si[[8;;10]]];, 
(* else *)
Icom = Partition[si[[8;;16]], 3];
];
Io[m, pos, Icom],
{si, I}
]
];


(* ::Input::Initialization:: *)
agfun::g = "Gravity not set.  Default is zero g.  Call RBDGravity[...] to change.";

agfun[x_:{}, \[Lambda]_:{}] := Lookup[rb, "g", Message[agfun::g]; (z6&)][If[x === {}, Array[\[DoubleStruckX], nx], x], If[\[Lambda] === {}, Array[\[DoubleStruckC], nc], \[Lambda]]];

XLfun[x_:{}, \[Lambda]_:{}] := EvaluateSpatialFunction["XL", x, \[Lambda]]; 
sfun[x_:{}, \[Lambda]_:{}] := EvaluateSpatialFunction["s", x, \[Lambda]];
\[DoubleStruckCapitalI]fun[x_:{}, \[Lambda]_:{}] := EvaluateSpatialFunction["\[DoubleStruckCapitalI]", x, \[Lambda]];

sdotfun[x_:{}, \[Lambda]_:{}] := EvaluateSpatialFunction["sdot", x, \[Lambda]];

XL0fun[x_:{}, \[Lambda]_:{}] := Block[{bx = nq (* compute all XL0 *)}, 
XL = XLfun[x, \[Lambda]];
X0[];
XL0
];

EvaluateSpatialFunction[spat_, x_:{}, \[Lambda]_:{}] := Module[{f, a, b},
a = If[x === {}, Array[\[DoubleStruckX], nx], x];
b = If[\[Lambda] === {}, Array[\[DoubleStruckC], nc], \[Lambda]];
f = Flatten@Values@RBDGetLinkInfo[spat, False];
Through[f[a, b]]
];


(* ::Input::Initialization:: *)
SetAttributes[RBDSpatialFunctions, Listable];

RBDSpatialFunctions[] := Module[{},
GetExpandedTree[]; (* calls GetTree[...] internally *)
(* get link names, if they exist *)
RBDSpatialFunctions[Keys@Lookup[rb, TreeForm, {}]]
];

RBDSpatialFunctions[b_] := Module[{n, k, jc, S, XT, sfun, sdotfun, Xfun(*, Xdotfun*), Ifun},
jc = rb[b, "joint"];
S = joint[jc];
n = Max[1, Length@S];
sfun = Xfun = Ifun = Table[0, n];
(* create pure functions for s, X, I *)
If[VectorQ[S, StringQ],
jc = S; (* save names *)
Do[
(* set motion freedoms for expanded links *)
sfun[[k]] = joint[jc[[k]]][\[DoubleStruckQ][b,k]];

(* links 2 to n are coincident with link 1 *)
XT = I6;
Xfun[[k]] = XJ[jc[[k]]][\[DoubleStruckQ][b,k]].XT;

(* zero inertia for links 1 to n-1 *)
Ifun[[k-1]] = Z6;,
{k, 2, n}
];

(* now get 1-dof code of first expanded joint of i *)
jc = jc [[1]];
S = joint[jc];
];

(* set up first and last links; these are equal for 1-dof links *)
sfun[[1]] = S[\[DoubleStruckQ][b,1]];

XT = Xba[rb[b, "frame"]];
Xfun[[1]] = XJ[jc][\[DoubleStruckQ][b,1]].XT; (* parent to child transform *)

Ifun[[-1]] = Itot[rb[b, "inertia"]];

(* make pure functions *)
S = ConvertToXLFunction[#, "dot" -> True][[2]]&;
{sdotfun(*, Xdotfun*)} = Map[S, {sfun(*, Xfun*)}, {2}];
{sfun, Xfun, Ifun} = Map[ConvertToXLFunction, {sfun, Xfun, Ifun}, {2}];

S = {sfun, sdotfun, Xfun(*, Xdotfun*), Ifun};
S = {"s", "sdot", "XL"(*, "XLdot"*), "\[DoubleStruckCapitalI]"} -> S;
AssociateTo[rb[b], AssociationThread[S]]
];


(* ::Input::Initialization:: *)
MovePoint[X_, p_] := Module[{R, fr},
(* SE(3) transformation *)
R = X[[1;;3,1;;3]];
fr = R\[Transpose].X[[4;;6,1;;3]];
fr = -deskew[fr];
R\[Transpose].p + fr
];


(* ::Input::Initialization:: *)
position[X_] := Module[{fr},
fr = X[[1;;3,1;;3]]\[Transpose].X[[4;;6,1;;3]];
-deskew[fr]
];

angle[E_] := Module[{x, y, z}, 
(* spatial transforms E rotate the parent's frame "backwards" writing the frame in the child's coordinate system *)
Which[
E[[3,1]] == -1,
z = 0;
y = -\[Pi]/2;
x = ArcTan[E[[1,3]], E[[2,3]]];,
E[[3,1]] == 1,
z = 0;
y = \[Pi]/2;
x = ArcTan[E[[2,2]], E[[2,3]]];,
True,
z = ArcTan[E[[1,1]], -E[[2,1]]];
y = ArcSin[E[[3,1]]];
x = ArcTan[E[[3,3]], -E[[3,2]]];
];

{x, y, z}
];

Tba[X_] := Module[{E, r},
(* from 6x6 spatial coordinates to 4x4 homogenous coordinates *)
E = X[[1;;3, 1;;3]];
r = position[X];
r = -E.r;
ArrayFlatten[{{E, {r}\[Transpose]}, {0, 1}}]
]

Options[RBDSpatialPosition] = {"Ep" -> False, "o" -> Root, "x" -> {}, "\[Lambda]" -> {}};

RBDSpatialPosition[X_?MatrixQ, OptionsPattern[]] := Module[{E, p},
E = X[[1;;3, 1;;3]];
p = position[X];
Which[
OptionValue["Ep"], {E, p},
MatrixQ[E, NumericQ], Join[EulerAngles[E\[Transpose] (* R \[Element] SO(3) *), {1,2,3}], p],
True, Join[z3, p]
]
];

(* bug need to use OptionValue["a"] as well *)
RBDSpatialPosition[\[DoubleStruckB][b_, r_, Xcb_, opts:OptionsPattern[\[DoubleStruckB]]]] := Module[{n, x, o},
(* redirect \[DoubleStruckB][b, r, Xcb, o] here *)
o = OptionValue[\[DoubleStruckB], {opts}, "o"];
x = RBDGetValue[1, nx];
x = RBDSpatialPosition[Xcb, b, "x" -> x, "Ep" -> False, "o" -> o];

o = IntegerQ[#] && 1 <= # <= nm&;
If[IntegerQ[r] || VectorQ[r, o], Sign[r]x[[Abs[r]]], r.x]
];

RBDSpatialPosition[XL0_ /; MatrixQ[XL0[[1]]], Xcb_, b_, opts:OptionsPattern[]] := Module[{i, j, X},
(* when animating use this version *)
i = RBDGetPositionIndex[b];
j = RBDGetPositionIndex[OptionValue["o"]];

X = If[VectorQ[Xcb], Xba[PadLeft[Xcb, nm]], Xcb];
X = If[i == 0, X, X.XL0[[i]]];
X = If[j == 0, X, X.InvXba[XL0[[j]]]];
RBDSpatialPosition[X, opts]
];

RBDSpatialPosition[Xcb_, b_, opts:OptionsPattern[]] := Module[{i, j, p, X, XL, up},
(* in general this is fastest if path is less than nq nodes *)
i = RBDGetPositionIndex[b];
j = RBDGetPositionIndex[OptionValue["o"]];
p = GetPath[i, j];

X = If[VectorQ[Xcb], Xba[PadLeft[Xcb, nm]], Xcb];
XL = XLfun[OptionValue["x"], OptionValue["\[Lambda]"]];

up = True;
Do[
Which[
j == 0, up = False;,
up, X = X.XL[[j]];,
True, X = X.InvXba[XL[[j]]];
];, 
{j, p}
];

RBDSpatialPosition[X, opts]
];


(* ::Input::Initialization:: *)
(* compute the kinetic and potential energy, spatial momentum, spatial inertia, mass, position of the center of mass, and the linear velocity of the center of mass of the entire system; vector quantities are in link 0 coordinates. *)
RBDMechanicalQuantities[] := Module[{p, vJ, v, hc, KE, PE, htot, Itot, m, mC, I, com, vcom, IC},
v = zspat;
hc = zspat;
KE = zq;
IC = \[DoubleStruckCapitalI];

Do[
p = parent[[i]];
vJ = s[[i]] qd[[i]];
If[p == 0,
(* only use relative link velocity *)
v[[i]] = vJ;, 
(* else *)
(* add parent's value *)
v[[i]] = XL[[i]].v[[p]] + vJ;
];
hc[[i]]=IC[[i]].v[[i]];
KE[[i]]=1/2 v[[i]].hc[[i]];, 
{i, nq}
];

Itot = Z6; (* rotational inertia *)
htot = z6; (* angular and linear momentum *)
Do[
p = parent[[i]];
If[p != 0, 
IC[[p]] = IC[[p]] + XL[[i]]\[Transpose].IC[[i]].XL[[i]];
hc[[p]] = hc[[p]] + XL[[i]]\[Transpose].hc[[i]];,
Itot=Itot+XL[[i]]\[Transpose].IC[[i]].XL[[i]];
htot=htot+XL[[i]]\[Transpose].hc[[i]];
];,
{i, nq, 1, -1}
];

Itot = mcI[Itot];
m = Itot[[1]]; (* total mass *)
com = Itot[[5;;7]]; (* center of mass *)
vcom = htot[[4;;6]]/m; (* center of mass velocity *)
I = Partition[Itot[[8;;]], mm]; (* rotational inertia about com *)

PE = m ag[[4;;6]].com; (* total potential energy *)
KE = Total[KE]; (* total kinetic energy *)

{KE, PE, htot, m, I, com, vcom}
];


(* ::Input::Initialization:: *)
End[]
EndPackage[]
