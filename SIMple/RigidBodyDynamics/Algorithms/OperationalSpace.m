(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Code::Initialization:: *)
(*
OperationalSpace.nb: An implementation of the OSIM algorithm
and its derivative.
Copyright (C) 2014 Nelson Rosa Jr.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version. This program is distributed in the 
hope that it will be useful, but WITHOUT ANY WARRANTY; without even the 
implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details. You should have 
received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.
*)


(* ::Input::Initialization:: *)
BeginPackage["RigidBodyDynamics`", "GlobalVariables`"]
Begin["`Private`"]


(* ::Input::Initialization:: *)
(* 
user inputs: none;
zeroed inputs: XL0, X0L, XL0dot, X0Ldot;
model data: XL, XLdot, parent, nq;
modifies: XL0, X0L, XL0dot, X0Ldot;
output: XL0, X0L, XL0dot, X0Ldot (transforms from/to root)
*)

X0[] := Module[{p, X, R, P},
(* compute transform X[b, 0] or X[o, 0] *)
XL0 = XL;
Do[p = parent[[i]];  If[p > 0, X = XL0[[i]]; XL0[[i]] = X.XL0[[p]]];, {i, bx}];
(* compute inverse transform *)
X0L = XL0;
Do[
R = X0L[[i,1;;3,1;;3]]\[Transpose];
P = -X0L[[i,4;;6,1;;3]];
X0L[[i,1;;3,1;;3]] = R;
X0L[[i,4;;6,4;;6]] = R;
X0L[[i,4;;6,1;;3]] = R.P.R;,
{i, bx}
];

(* create corresponding rotation matrices *)
RL0 = XL0;
Do[RL0[[i, 4;;6, 1;;3]] = Z3; ,{i, bx}];
R0L = Transpose[RL0, {1, 3, 2}];
];


(* ::Input::Initialization:: *)
(*posX = Join[z3, position[#]]&;*)

(* assuming singularities won't occur *)
(*angX = {ArcTan[#\[LeftDoubleBracket]3,3\[RightDoubleBracket], -#\[LeftDoubleBracket]3,2\[RightDoubleBracket]], ArcSin[#\[LeftDoubleBracket]3,1\[RightDoubleBracket]], ArcTan[#\[LeftDoubleBracket]1,1\[RightDoubleBracket], -#\[LeftDoubleBracket]2,1\[RightDoubleBracket]]}&;

posX = position[#]&;*)

posX = Join[{ArcTan[#2[[3,3]], -#2[[3,2]]], ArcSin[#2[[3,1]]], ArcTan[#2[[1,1]], -#2[[2,1]]]}, position[#1]]&;

V[] := Module[{p, vJ},
v = zspat;
Do[
p = parent[[i]];
vJ = s[[i]] qd[[i]];
If[p == 0, 
v[[i]] = vJ;, 
v[[i]] = XL[[i]].v[[p]] + vJ;
];, 
{i, nq}
];
];

rs0[] := Module[{Xdot, va, vo0, vX, b, o, X, R},
(* move joint and constraint vectors into world frame *)
sj = s; (* move s into world frame, sj = X[0, j].s[j, j] *)
sjdot = sdot; (* move sdot into world frame *)
Do[
sj[[i]] = X0L[[i]].s[[i]];
vX = X0L[[i]].v[[i]];
Xdot = mxX[vX, X0L[[i]]];
sjdot[[i]] = X0L[[i]].sdot[[i]] + Xdot.s[[i]];,
{i, bs}
];

Xo0 = Tcb;
ro = r;
rodot = rdot;
posXco = zpos;

Do[
b = bo[[k, 1]];
o = bo[[k, 2]];

(* compute X transform from 0 (root/world frame) to o *)
(* transforms are root \[Rule] b \[Rule] c \[Rule] 0, i.e, X[o, c].X[c, b].X[b, 0] *)
If[o == 0, 
Xo0[[k]] = R0L[[b]].Tcb[[k]].XL0[[b]];
R = RL0[[b]];
X = Xo0[[k]];, 
Xo0[[k]] = RL0[[o]].R0L[[b]].Tcb[[k]].XL0[[b]];
R = RL0[[b]].R0L[[o]];
X = Xo0[[k]].X0L[[o]];
];

(* spatial position of constraint in o frame *)
posXco[[k]] = r[[k]].posX[X, R];

(* move r into world frame, ro = r[o, o].X[o, 0] *)
ro[[k]] = r[[k]].Xo0[[k]];

(* move rdot into world frame, rodot = d/dt(r[o, o].X[o, 0]) *)
va = v[[b]];
va[[4;;6]] = z3; (* only angular vel of vb *)
vo0 = R0L[[b]].va-R0L[[b]].Tcb[[k]].v[[b]]; (* vel w/ o = 0 *)
If[o !=  0, 
va = v[[o]];
va[[4;;6]] = z3; (* only angular vel of vo *)
vo0 = RL0[[o]].vo0 - va;
];
Xdot = mxX[vo0, Xo0[[k]]];
rodot[[k]] =  rdot[[k]].Xo0[[k]] + r[[k]].Xdot;, 
{k, Length@bo}
];
];


(* ::Input::Initialization:: *)
(* 
user inputs: x;
zeroed inputs: J;
mode data: r, s, XL, parent, bodies, mb, X0L and friends;
modifies: J;
output: J & \[Phi] (joint velocities to os velocities)
*)

JOSIM[] := Module[{b, aa, oo, ii, j, kk, n, in, kn, nn},
(* compute J and \[Phi] in J.a + \[Phi] = 0*)
Do[
b = ba[[c, 1, 1]]; (* all c's have same b and a *)
aa = ba[[c, 1, 2]];
(* get all constraint i's and corresponding k's that would traverse *)(* the same path up the tree *)
n = Length@ba[[c]];

{ii, kk} = Select[ba[[c, 1;;n, 4;;5]], #[[1]] != 0&]\[Transpose];
nn = Length@ii;
(*ii = ba\[LeftDoubleBracket]c, 1;;n, 3\[RightDoubleBracket];
kk = ba\[LeftDoubleBracket]c, 1;;n, 4\[RightDoubleBracket];*)

(* compute i-th constraint starting with body b *)
Do[
in = ii[[cc]];
kn = kk[[cc]];
J[[in, b]] = J[[in, b]] + ro[[kn]].sj[[b]];
(* \[Phi] = \[Phi] + Jdot qd *)
\[Phi][[in]] = \[Phi][[in]] + (rodot[[kn]].sj[[b]] + ro[[kn]].sjdot[[b]])qd[[b]];, 
{cc, nn}
];

(* below we have errors if adding to same ii, e.g., ii = {1, 1}, kk = {1, 2}. *)
(*J\[LeftDoubleBracket]ii, b\[RightDoubleBracket] = J\[LeftDoubleBracket]ii, b\[RightDoubleBracket] + ro\[LeftDoubleBracket]kk\[RightDoubleBracket].sj\[LeftDoubleBracket]b\[RightDoubleBracket];*)
(* \[Phi] = \[Phi] + Jdot qd *)
(*\[Phi]\[LeftDoubleBracket]ii\[RightDoubleBracket] = \[Phi]\[LeftDoubleBracket]ii\[RightDoubleBracket] + (rodot\[LeftDoubleBracket]kk\[RightDoubleBracket].sj\[LeftDoubleBracket]b\[RightDoubleBracket] + ro\[LeftDoubleBracket]kk\[RightDoubleBracket].sjdot\[LeftDoubleBracket]b\[RightDoubleBracket])qd\[LeftDoubleBracket]b\[RightDoubleBracket];*)

(* and ending at root *)
j = parent[[b]];
While[j != 0 && j  >= aa,
(*J\[LeftDoubleBracket]ii, j\[RightDoubleBracket] = J\[LeftDoubleBracket]ii, j\[RightDoubleBracket] +ro\[LeftDoubleBracket]kk\[RightDoubleBracket].sj\[LeftDoubleBracket]j\[RightDoubleBracket];*)
(*\[Phi]\[LeftDoubleBracket]ii\[RightDoubleBracket] = \[Phi]\[LeftDoubleBracket]ii\[RightDoubleBracket] + (rodot\[LeftDoubleBracket]kk\[RightDoubleBracket].sj\[LeftDoubleBracket]j\[RightDoubleBracket] + ro\[LeftDoubleBracket]kk\[RightDoubleBracket].sjdot\[LeftDoubleBracket]j\[RightDoubleBracket]) qd\[LeftDoubleBracket]j\[RightDoubleBracket];*)

Do[
in = ii[[cc]];
kn = kk[[cc]];
J[[in, j]] = J[[in, j]] + ro[[kn]].sj[[j]];
\[Phi][[in]] = \[Phi][[in]] + (rodot[[kn]].sj[[j]] + ro[[kn]].sjdot[[j]])qd[[j]];, 
{cc, nn}
];

j = parent[[j]];
];

(* \[Eta] = (h, hdot) (ideally \[Eta] = 0) *)
(* h *)
{oo, ii, kk} = Select[ba[[c, 1;;n, 3;;5]], #[[2]] != 0 && #[[1]] <= 0&]\[Transpose];
\[Eta][[1, ii]] = \[Eta][[1, ii]] + posXco[[kk]];
(* hdot *)
{oo, ii, kk} = Select[ba[[c, 1;;n, 3;;5]], #[[2]] != 0 && #[[1]] <= 1&]\[Transpose];
\[Eta][[2, ii]] = \[Eta][[2, ii]] + J[[ii]].qd;, 
{c, Length@ba}
];

(* v = K.\[Eta]; useful for constraint stabilization & HZD feedback control *)
If[Length@ba > 0, \[Phi] = \[Phi] + K[[1]].\[Eta][[1]] + K[[2]].\[Eta][[2]]];
];


(* ::Input::Initialization:: *)
End[]
EndPackage[]
